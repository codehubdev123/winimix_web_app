import { NextRequest, NextResponse } from "next/server";
import { BaseController } from "../../shared/BaseController";
import { validateFormData } from "@/utils/validateFormData";
import { EditCategorySchema } from "../validations/CreateCategotySchema";
import { deleteImageFromFirebase } from "../../shared/firebaseStorage";
import { adminDb } from "@/lib/firebase-admin";
import { categoryCollection } from "../../shared/collections/Collections";
import { EditUseCase } from "../useCases/EditUseCase";
import { GetCategoryByIdUseCase } from "../useCases/GetCategoryByIdUseCase";
import validationUtils from "../../shared/utils/ValidationUtils";

export class CategoryUpdateController extends BaseController {
  private readonly editUsecase: EditUseCase;
  private readonly getCategoryByIdUseCase: GetCategoryByIdUseCase;
  constructor(
    editUseCase: EditUseCase,
    getCategoryByIdUseCase: GetCategoryByIdUseCase,
  ) {
    super();
    this.editUsecase = editUseCase;
    this.getCategoryByIdUseCase = getCategoryByIdUseCase;
  }

  public async execute(req: NextRequest, params: any) {
    const { id } = await params;
    const body = await req.formData();
    // Explanation: Parse and validate update data
    const validatedData = await validateFormData(EditCategorySchema, body);
    if (!validatedData.success) {
      return this.error({
        errors: validatedData.errors,
        fieldErrors: validatedData.fieldErrors,
      });
    }

    // Explanation: Validate category ID
    const isValidId = validationUtils.validateId(id);
    if (!isValidId) {
      return this.error({
        message: "Invalid category ID",
        errors: ["Category ID is required and must be a string"],
      });
    }

    // Explanation: Check if category exists before updating
    // const doc = await adminDb.collection(categoryCollection).doc(id).get();
    const doc = await this.getCategoryByIdUseCase.execute(id);
    // Explanation: Handle case where category doesn't exist
    if (!doc.exists) {
      return this.error({ status: 404, message: "Category  not found" });
    }
    const existingData = doc.data();

    // Handle image upload
    const imageFile = body.get("image") as File;
    const removeImage = body.get("removeImage") === "true";
    let imageUrl = existingData.image; // Start with existing image
    console.log("ğŸ–¼ï¸ Image handling:", {
      hasImageFile: !!imageFile,
      removeImageFlag: removeImage,
      existingImage: existingData.image,
    });

    if (imageFile && imageFile.size > 0) {
      console.log("ğŸ–¼ï¸ Starting image upload...");
      // Upload image to Firebase Storage
      try {
        // Delete old image
        // Explanation: Perform deletion
        await deleteImageFromFirebase(existingData.image);
        console.log("âœ… Old image deleted from Firebase Storage");
        console.log("ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´ğŸ”´ HERE FROM TRY ");
        // imageUrl = await uploadImageToFirebase(imageFile, "categories");
        console.log("âœ… Image uploaded successfully:", imageUrl);
      } catch (uploadError) {
        console.error("âŒ Image upload failed:", uploadError);
        return this.error({
          message: "Field to upload image",
        });
      }
    }
    // return this.success({ message: "Message is here" });

    // Explanation: Prepare update data with new timestamp
    const updateData = {
      ...validatedData.data,
      updatedAt: new Date(),
      image: imageUrl, // url after uploaded to Firebase
    };
    // Explanation: Perform the update operation
    //     await adminDb.collection(categoryCollection).doc(id).update(updateData);
    const docRef = await this.editUsecase.execute(id, updateData);
    // Explanation: Fetch updated document to return complete data
    const updatedDoc = await adminDb
      .collection(categoryCollection)
      .doc(id)
      .get();

    return this.success({
      message: "Category updated successfully",
      data: {
        id: updatedDoc.id,
        ...updatedDoc.data(),
      },
    });
  }
}
